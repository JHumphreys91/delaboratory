#summary Benchmarking delaboratory

== Introduction ==
There are two benchmarks in delaboratory.

They measure time for two critical operations:
  * color conversion
  * blur

These benchmarks measure time so *smaller is better*.

== Color Conversion ==

http://delaboratory.googlecode.com/svn/trunk/screenshots/benchmark_colors.jpg

Each line shows how long it takes to convert 10 million pixels from one colorspace to another.

== Blur ==

http://delaboratory.googlecode.com/svn/trunk/screenshots/benchmark_blur.jpg

This test calls blur on single channel (so if you want to know numbers for RGB you need to multiply these values by 3).

First column shows image size. 1024x768 is quite small image which may fit on the screen (so delaboratory could use this size in realtime), 4000x3000 is size which won't fit on screen but original 12MP photo may be something like that.

The second column shows blur type and radius. In delaboratory radius is not given in pixels, but is a fraction of total image size. So radius 0.1 means 10% of image width or height. 

The third column shows time of blur operation. As you can see blur with biggest radius is quite slow. You should remember about it when using blur layer and USM layer. 

== Usage ==

These values should be stable, if you run it twice you should see similar results. 

You can use these benchmarks to:

  * see how compilation options affect speed
  * compare speed under two different computers of operating systems (from the delaboratory point of view)
  * observe how long it takes to perform blur with given radius

Benchmarks measure global time, not process time, so if you start other processes in the background - results will be worse. So you can also check how other stuff slow downs your system.

== Example ==

This is comparision of different compilation options on same system.

http://delaboratory.googlecode.com/svn/trunk/screenshots/o3_vs_ofast_march_core2.png

  * Left: *-O3*
  * Right: *-Ofast -march-core2*

As you can see, the difference is dramatic.
So it may be good idea to compile for your specific architecture.
(see http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_002d64-Options.html)